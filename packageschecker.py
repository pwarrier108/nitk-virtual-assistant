import os
import ast
from pathlib import Path
import pkg_resources
import sys
import pkgutil

# List of packages to exclude (system libraries and others that aren't on PyPI)
EXCLUDE_PACKAGES = {
    'OpenSSL',  # System library
    'PIL',      # Use 'Pillow' instead
    'win32',    # System specific
    'win32api', 
    'wx',       # System specific
    'tkinter',  # Built-in
    'Tkinter',
    '_tkinter',
    'gtk',      # System specific
    'PyQt5.Qt', # Use 'PyQt5' instead
    'cryptography', # Special installation requirements
    # Add more as needed
}

def is_third_party_package(name):
    """Check if a package is a third-party PyPI package."""
    if (name.startswith('_') or 
        name in sys.stdlib_module_names or 
        name in EXCLUDE_PACKAGES or
        name.lower() in {x.lower() for x in EXCLUDE_PACKAGES}):
        return False
    
    try:
        # Try to get the module's file location
        spec = importlib.util.find_spec(name)
        if spec is None:
            return True  # Might be a third-party package that's not installed
        
        # If it's in site-packages, it's likely a third-party package
        if spec.origin and 'site-packages' in spec.origin:
            return True
        
        return False
    except ImportError:
        return True  # If we can't import it, assume it's third-party

def extract_imports(file_path):
    """Extract import statements from a Python file."""
    try:
        with open(file_path, 'r', encoding='utf-8') as file:
            tree = ast.parse(file.read())
        
        imports = set()
        for node in ast.walk(tree):
            if isinstance(node, ast.Import):
                for name in node.names:
                    base_name = name.name.split('.')[0]
                    if is_third_party_package(base_name):
                        imports.add(base_name)
            elif isinstance(node, ast.ImportFrom):
                if node.module:
                    base_name = node.module.split('.')[0]
                    if is_third_party_package(base_name):
                        imports.add(base_name)
        
        return imports
    except Exception as e:
        print(f"Error processing {file_path}: {e}")
        return set()

def find_installed_packages():
    """Get a list of installed third-party packages with versions."""
    try:
        installed = {}
        for dist in pkg_resources.working_set:
            if dist.key not in EXCLUDE_PACKAGES:
                installed[dist.key] = dist.version
        return installed
    except Exception as e:
        print(f"Warning: Error getting installed packages: {e}")
        return {}

def generate_requirements(directory):
    """Generate requirements.txt from Python files in directory."""
    required_packages = set()
    
    # Recursively walk through directory
    for path in Path(directory).rglob('*.py'):
        required_packages.update(extract_imports(path))
    
    # Get installed packages and their versions
    installed_packages = find_installed_packages()
    
    # Write to requirements.txt
    with open('requirements.txt', 'w') as f:
        f.write("# Generated by requirements generator\n")
        f.write("# Packages required for this project\n\n")
        
        for package in sorted(required_packages):
            if package in installed_packages:
                f.write(f"{package}=={installed_packages[package]}\n")
            else:
                print(f"Warning: Package '{package}' is imported but not installed")
                f.write(f"# {package}  # Not currently installed\n")

    print(f"Generated requirements.txt with {len(required_packages)} packages")
    print("Note: Comments have been added for packages that aren't currently installed")

if __name__ == "__main__":
    import importlib.util
    source_dir = "."  # Current directory
    generate_requirements(source_dir)